week2 


【homework1】
design document of hash_table.py
アルゴリズムの説明、プログラムの実行方法、工夫した点などを第三者にも伝わるように「わかりやすく」書く




概要
key(string)とvalue(何の型でもOK)をペアで持つデータを格納するためのhash tableを作った
put、get、delete機能を実装した。
1. ハッシュ値の割り振り
keyのhash値をcalculate_hashで計算する。それぞれのkeyに何らかの値を与えた。
   1. 要素数が増えたときに再ハッシュすることを考え、同じkeyのハッシュ値を何度も計算しないよう、要素を格納する際にdicにkeyとkeyのハッシュ値を保存した。
   2. これ以降、再ハッシュの際や、要素を検索する際は、まずdicを参照するようにした     
2. 格納
hash値をbucket_sizeで割り算してhash tableに格納した。ハッシュ値が衝突した際には、連結リストで繋いだ。
3. 再ハッシュ
要素数がbucket sizeの70%以上（つまりキャパが埋まってきた時）はハッシュテーブルの長さを二倍にした。逆に、要素数がbucket sizeの30%以下（つまりすかすかな時）はハッシュテーブルの長さを半分にした。この時、bucket sizeは必ず奇数になるようにした。


実行方法
functional_test
いくつかの具体的なkeyとvalueを入力し、put、get、deleteを試した


performance_test
0~1億のうちから乱数を生成し、それらをkeyとvalueにして100回ずつput、get、deleteした。


工夫した点
* 何度も同じkeyに対してハッシュ値を計算することのないよう、dicに保存して計算量を減らした
* ハッシュ関数を工夫した。元々 Σord(char) だったが、Πord(char)にした


課題、不明点
* ハッシュ関数がまだ改善できそう
   * そもそも積にした方が良いのか？？どうせbucket_sizeで割ってしまうから衝突するかどうかは和でも積でも変わらないのでは？
   * ハッシュ値をユニークなものにするという視点だけで考えると、例えば、ord(char)ではなく、char一つ一つに新たに素数を割り当てて、それらの積を取った方が良い？
      * そうなると、a~z、A~Z、0~9、その他記号にも割り当てる必要がある？？
* bucket sizeを奇数にしたが、近くのprime numberを探して設定しても良いかもしれない（find_prime_number()みたいな関数を作る？でも素数の探索って意外と大変かもしれない）


【homework2】
* 木構造を使えば O(log N)、ハッシュテーブルを使えばほぼ O(1) で検索・追加・削除を実現することができて、これだけ見ればハッシュテーブルのほうが優れているように見える。ところが現実の大規模なデータベースでは、ハッシュテーブルではなく木構造が使われることが多い。その理由を考えよ。
* いくつか重要な理由があるので思いつくだけ書いてください！


* 木構造の場合、大きさを指定しなくて良いから。ハッシュテーブルは大きさを指定する必要がある。例えば、googleのユーザのDBを作ろうとしたら、総ユーザ数を予想するのは難しいし、ユーザの増加によって再ハッシュするのは、Nが大きくなればなるほど大変だから。
* 構造を変えるのが簡単（例えば、授業で扱ったbalance木も数箇所いじるだけで全体の構造を調整することができた）で、扱いやすいから。


【homework3】
* もっとも単純には、「URL」をキー、「Webページ」を値とするハッシュテーブルを用意すればよい
* もっとも直近にアクセスされたページ上位 X 個をキャッシュしておく😊
* アクセス系列が「A, A, A, A, B, A, C, D, D, B, B, D, B, E」ならば、「B, D, E」をキャッシュ
* このようなキャッシュの管理をほぼ O(1) で実現できるデータ構造を考えてください！(σ⁎˃ᴗ˂⁎)σ


dicとlinked nodeを組み合わせる
* dicでキャッシュリストに存在するかどうかを確認
* linked listで順番を作る -> deleteしやすい、順番変えやすい


【homework4】
design document of cache.py
アルゴリズムの説明、プログラムの実行方法、工夫した点などを第三者にも伝わるように「わかりやすく」書く


アルゴリズムの説明
ブラウザのキャッシュ機能（最近アクセスされたN個のwebsiteのキャッシュ）の実装
キャッシュは新たに追加された順に並べておく、ただし計算量はO(1)
1. 何らかのページにアクセスする。キャッシュを確認する。
2. もしキャッシュにそのページがなければ、キャッシュに追加する。N個しか保存できないため、一番古いページは捨てる。
3. もしキャッシュにあれば、キャッシュのメンツ自体は変えない。一方で、新しい順に管理したいので、最新アクセスとしてステータスを更新する。
   1. この「新しい順」というのは連結リストで管理している。
プログラムの実行方法
tests caseで確認
* 最初の1~N個目
* N個cacheに保存された後に
   * cacheに存在しないページへのアクセス
   * 存在するページへのアクセス
      * latestページにさらにアクセス
      * latestではないページへのアクセス
      * oldestページへのアクセス


工夫した点
* dicとlinked listの併用による効率的なcache
* 連結リストの一つ前の要素を参照するとき、連結リストに.prevという概念を導入して参照する手もあったが、while文で対応した