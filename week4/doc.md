week4
# hw1 最短経路を求める
- 基本的にはbfsコード
- キューを使って探索中のノードを管理
- キューに入れる値を変えた
  - ベーシックなやつでは、ノードを格納するはず
  - 今回は、始点からの履歴をリストとして保存し、格納
  - 例えば、A(スタート)からB、Cにつながっているとしたら、キューには[A,B][A,C]を格納。BからD、Eにつながっているとしたら、[A,B]をpop、[A,B,D][A,B,E]をappend。
  - 終点に一番遠いコードは、リストの末尾にあるのでlist[-1]を参照
- goalにたどり着いたら、履歴を表示
### 問題点
listの再生成をしているため、時間計算量、空間計算量ともにかさむ。

# hw2 popular pagesを求める
- 現在のidとpagerankを記録したpagerank辞書
- 更新用のnew_pagerank辞書
- まず、全ノードに初期値1.0を配分
- 更新ループ
  - メモとして使用する、new_pagerank、res、resultはループのたびに毎回初期化
  - まず、self.linksを参照し、全てのノードの対応ノードを洗う。
    - 伸びているノードがない(行き止まり)の場合は、pagerankを全ノードに配分。
      全コードを呼び出さなければならない作業＝いちいち呼び出すと計算量がかさむ、のでresにとりあえずメモ。後ほどresが揃ってから一斉に更新する。
    - 行き止まりでない場合、85%をつながっているノードに、15%を全ノードに配分
    - 85%分の更新は特定のいくつかのidのみに行う作業であるから、この時点で該当ノードに更新をかける。
      15%については、全コードを呼び出さなければならない作業＝いちいち呼び出すと計算量がかさむ、のでresにとりあえずメモ。後ほどresが揃ってから一斉に更新する。
  - 全ノードのlink先を参照したら(for文を抜けたら)、もう一回ループを回す。今度はメモしておいたresを全ノードに加える(一斉更新)。このとき、pagerank更新幅(差の二乗)も計算しておく。また、更新後のidとpagerankをresultというリストにメモ。
- pagerank更新幅が小さくなったら(diff < 0.01)≒収束したら終了。直前のループでメモしたresultを用い、pagerankが大きい10つのpagesを出力する。
### 工夫
全ノード共通の計算はいちいち呼び出さず、全部揃ってから一斉に更新した。
